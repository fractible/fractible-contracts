archetype sales(
    owner: address,
    protocol_fee: nat,
    transfer_manager: address,
    sales_storage: address
)
with metadata ""

constant AMOUNT_MISMATCH         : string = "AMOUNT_MISMATCH"
constant BUNDLE_CANT_BE_EMPTY    : string = "BUNDLE_CANT_BE_EMPTY"
constant CANT_UNPACK_BUNDLE      : string = "CANT_UNPACK_BUNDLE"
constant CANT_UNPACK_FA12_ASSET  : string = "CANT_UNPACK_FA12_ASSET"
constant CANT_UNPACK_FA2_ASSET   : string = "CANT_UNPACK_FA2_ASSET"
constant FEES_OVER_SELLER_LIMIT  : string = "FEES_OVER_SELLER_LIMIT"
constant INVALID_BUNDLE_ITEM_QTY : string = "INVALID_BUNDLE_ITEM_QTY"
constant INVALID_BUY_AMOUNT      : string = "INVALID_BUY_AMOUNT"
constant INVALID_CALLER          : string = "INVALID_CALLER"
constant INVALID_SALE_END_DATE   : string = "INVALID_SALE_END_DATE"
constant INVALID_SALE_START_DATE : string = "INVALID_SALE_START_DATE"
constant MAX_BUNDLE_SIZE         : string = "MAX_BUNDLE_SIZE"
constant MISSING_BUNDLE_SALE     : string = "MISSING_BUNDLE_SALE"
constant MISSING_CANDIDATE       : string = "MISSING_CANDIDATE"
constant MISSING_SALE            : string = "MISSING_SALE"
constant SALE_ALREADY_EXISTS     : string = "SALE_ALREADY_EXISTS"
constant SALE_CLOSED             : string = "SALE_CLOSED"
constant SALE_NOT_STARTED        : string = "SALE_NOT_STARTED"
constant WRONG_XTZ_PAYLOAD       : string = "WRONG_XTZ_PAYLOAD"

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none
variable max_bundle_items : nat = 10
variable max_fees_limit : nat = 10000

entry declare_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  constant {
    candidate ?is owner_candidate otherwise MISSING_CANDIDATE
  }
  require {
    r0: caller = candidate otherwise INVALID_CALLER
  }
  effect {
    owner := candidate;
    owner_candidate := none
  }
}


//----------------------------------------------------------------------------
// Admin
//----------------------------------------------------------------------------
entry set_sales_storage_contract(sesc_contract : address) {
  called by owner
  effect {
    sales_storage := sesc_contract;
  }
}

entry set_protocol_fee(spf : nat) {
  called by owner
  effect {
    protocol_fee := spf;
  }
}

entry set_fees_limit(sfl : nat) {
  called by owner
  effect {
    max_fees_limit := sfl;
  }
}

entry set_transfer_manager(stm_contract : address) {
  called by owner
  effect {
    transfer_manager := stm_contract;
  }
}

entry set_sales_storage(sss_contract : address) {
  called by owner
  effect {
    sales_storage := sss_contract;
  }
}

entry set_max_bundle_items(smbi_number : nat) {
  called by owner
  effect {
    max_bundle_items := smbi_number;
  }
}

//----------------------------------------------------------------------------
// Types
//----------------------------------------------------------------------------
record transfer_param {
  destination_address: address;
  token_id: nat;
  token_amount: nat
} as ((%to, (token_id, amount)))

record sale {
  sale_contract: address;
  sale_token_id: nat;
  sale_seller: address;
  sale_price_per_item: nat;
  sale_qty: nat;
  sale_start: option<date>;
  sale_end: option<date>;
  sale_version: nat;
  sale_data_type  : bytes;
  sale_data       : bytes;
}

entry sell (
  s_sale : sale) {
    constant {
      start_date is s_sale.sale_start ? the: now;
    }
    require {
      sell_invalid_price: s_sale.sale_price_per_item > 0;
      sell_invalid_qty: s_sale.sale_qty > 0;
    }
    effect {
      match s_sale.sale_end with
      | some(end_date) -> begin
        do_require(end_date > now, "SALE_END_IN_THE_PAST");
        do_require(end_date > start_date, "SALE_END_BEFORE_START");
      end
      | none -> ()
      end;
      transfer 0tz to sales_storage call set_sale<sale>(s_sale);
    }
}


entry buy(
  b_sale_id: nat,
  b_qty: nat){
    constant {
      stored_sale ?is get_sale(b_sale_id) otherwise "MISSING_SALE";
      stored_sale_stock is stored_sale.sale_qty;
      stored_sale_start is stored_sale.sale_start;
      stored_sale_end is stored_sale.sale_end;
    }
    require {
      buy_incorrect_qty: b_qty > 0 and b_qty >= stored_sale_stock
    }
    effect {
      match stored_sale_end with
      | some(end_date) -> begin
        do_require(end_date > now, SALE_CLOSED);
      end
      | none -> ()
      end;

      match stored_sale_start with
      | some(sale_start) -> begin
        do_require(sale_start < now, SALE_NOT_STARTED);
      end
      | none -> ()
      end;


      if(b_qty = stored_sale_stock) then (
        transfer 0tz to sales_storage call remove_sale<nat>(b_sale_id)
      ) else (
        stored_sale.sale_qty := abs(stored_sale.sale_qty - b_qty);
        transfer 0tz to sales_storage call update_sale<nat * sale>(
          (
            b_sale_id,
            stored_sale
          )
        );
      )
    }
}



entry cancel_sale(cs_sale_id: nat){
    require {
        r_cs0: sale_exists(cs_sale_id) = true;
    }
    effect {
      transfer 0tz to sales_storage call remove_sale<nat>(cs_sale_id)
    }
}

function sale_exists(se_sale_id: nat) : bool {
    return match call_view<bool>(
        sales_storage,
        "sale_exists",
        se_sale_id
    )
    with
        | some(v) -> v
        | none -> false
    end
}


function get_sale(gs_sale_id: nat) : option<sale> {
    return (call_view<option<sale>>(
        sales_storage,
        "get_sale",
        gs_sale_id
    ) ? the : none<sale>)
}

entry default() {}