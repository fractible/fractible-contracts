archetype sales_storage(
  owner: address
)
with metadata ""

variable id_sequence : nat = 0

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none

entry declare_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  constant {
    candidate ?is owner_candidate otherwise "MISSING_CANDIDATE"
  }
  require {
    r0: caller = candidate otherwise "INVALID_CALLER"
  }
  effect {
    owner := candidate;
    owner_candidate := none
  }
}

//----------------------------------------------------------------------------
// Admin
//----------------------------------------------------------------------------
variable authorized_contracts   : set<address> = []

entry authorize_contract(ac_contract : address) {
  called by owner
  effect {
    authorized_contracts.add(ac_contract)
  }
}

entry revoke_contract(ac_contract : address) {
  called by owner
  effect {
    authorized_contracts.remove(ac_contract)
  }
}

function is_authorized() : bool {
  if (authorized_contracts.contains(caller) or caller = self_address)
  then return true
  else fail("NOT_AUTHORIZED")
}

//----------------------------------------------------------------------------
// Auction
//----------------------------------------------------------------------------

record sale {
  sale_contract: address;
  sale_token_id: nat;
  sale_seller: address;
  sale_price_per_item: nat;
  sale_qty: nat;
  sale_start: option<date>;
  sale_end: option<date>;
  sale_version: nat;
  sale_data_type  : bytes;
  sale_data       : bytes;
}

asset sales identified by sale_id {
  sale_id : nat;
  sale_record: sale;
}

entry set_sale(
  ss_sale: sale) {
  constant{
    ss_same_sales is sales.select(
      sale_record.sale_contract = ss_sale.sale_contract
      and sale_record.sale_token_id = ss_sale.sale_token_id
      and sale_record.sale_seller = ss_sale.sale_seller);
  }
  require {
    r_set_sale_authorized: is_authorized();
    r_sale_exists: ss_same_sales.count() = 0;
  }
  effect {
    sales.add_update(
      id_sequence,
      {
        sale_record = ss_sale
      }
    );
    id_sequence := id_sequence + 1;
  }
}

entry update_sale(
  us_sale_id: nat,
  us_sale: sale) {
  constant{
    update_sale_same_sales is sales.select(
      sale_record.sale_contract = us_sale.sale_contract
      and sale_record.sale_token_id = us_sale.sale_token_id
      and sale_record.sale_seller = us_sale.sale_seller);
  }
  require {
    update_sale_authorized: is_authorized();
    update_sale_exists: update_sale_same_sales.count() > 0;
  }
  effect {
    sales.add_update(
      us_sale_id,
      {
        sale_record = us_sale
      }
    );
  }
}


entry remove_sale(
  rs_sale_id: nat) {
  require {
    r_remove_sale_authorized: is_authorized()
  }
  effect {
    sales.remove(rs_sale_id);
  }
}

view sale_exists(
  se_sale_id: nat) : bool {
  return sales.contains(se_sale_id)
}


view get_sale(
  gs_sale_id: nat) : option<sale> {
  return sales[gs_sale_id]?.sale_record
}

entry default() {}