archetype marketplace_storage(
  owner: address
)
with metadata ""

variable id_sequence : nat = 0

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none

entry declare_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  constant {
    candidate ?is owner_candidate otherwise "MISSING_CANDIDATE"
  }
  require {
    r0: caller = candidate otherwise "INVALID_CALLER"
  }
  effect {
    owner := candidate;
    owner_candidate := none
  }
}

//----------------------------------------------------------------------------
// Admin
//----------------------------------------------------------------------------

/* Authorized ------------------------------------------------------------ */
asset authorised {
  authorization : address
}

enum authorization_op =
| add<address>
| remove<address>

entry manage_authorization(op : authorization_op) {
  called by owner
  effect {
    match op with
    | add(a)    -> authorised.add({ a })
    | remove(a) -> authorised.remove(a)
    end
  }
}

//----------------------------------------------------------------------------
// Auction
//----------------------------------------------------------------------------

record sale {
  sale_contract: address;
  sale_token_id: nat;
  sale_seller: address;
  sale_price_per_item: nat;
  sale_qty: nat;
  sale_start: option<date>;
  sale_end: option<date>;
  sale_version: nat;
  sale_data_type  : option<bytes>;
  sale_data       : option<bytes>;
}

asset sales identified by sale_id {
  sale_id : nat;
  sale_record: sale;
}

entry set_sale(
  ss_sale: sale) {
  called by authorised
  constant{
    ss_same_sales is sales.select(
      sale_record.sale_contract = ss_sale.sale_contract
      and sale_record.sale_token_id = ss_sale.sale_token_id
      and sale_record.sale_seller = ss_sale.sale_seller);
  }
  require {
    r_sale_exists: ss_same_sales.count() = 0;
  }
  effect {
    sales.add_update(
      id_sequence,
      {
        sale_record = ss_sale
      }
    );
    id_sequence := id_sequence + 1;
  }
}

entry update_sale(
  us_sale_id: nat,
  us_sale: sale) {
  called by authorised
  constant{
    update_sale_same_sales is sales.select(
      sale_record.sale_contract = us_sale.sale_contract
      and sale_record.sale_token_id = us_sale.sale_token_id
      and sale_record.sale_seller = us_sale.sale_seller);
  }
  require {
    update_sale_exists: update_sale_same_sales.count() > 0;
  }
  effect {
    sales.add_update(
      us_sale_id,
      {
        sale_record = us_sale
      }
    );
  }
}

entry remove_sale(
  rs_sale_id: nat) {
  called by authorised
  effect {
    sales.remove(rs_sale_id);
  }
}

entry remove_sales(
  rcs_sale_ids: list<nat>) {
  called by authorised
  constant{
    selected_sales is sales.select(rcs_sale_ids.contains(the.sale_id));
  }
  effect {
    for selected_sale_id in selected_sales do
      do_require(sales[selected_sale_id].sale_record.sale_contract = caller, "INVALID_CALLER");
      sales.remove(selected_sale_id)
    done
  }
}

entry cancel_matching_orders(
  cmo_contract: address,
  cmo_token_id: nat,
  cmo_owner: address,
  ) {
  called by authorised
  constant{
    matching_orders is sales.select(
      sale_record.sale_contract = cmo_contract
      and sale_record.sale_token_id = cmo_token_id
      and sale_record.sale_seller = cmo_owner
    );
  }
  effect {
    for matching_sale_id in matching_orders do
      do_require(sales[matching_sale_id].sale_record.sale_contract = caller, "INVALID_CALLER");
      sales.remove(matching_sale_id)
    done
  }
}

view sale_exists(
  se_sale_id: nat) : bool {
  return sales.contains(se_sale_id)
}

view get_sale(
  gs_sale_id: nat) : option<sale> {
  return sales[gs_sale_id]?.sale_record
}

entry default() {}